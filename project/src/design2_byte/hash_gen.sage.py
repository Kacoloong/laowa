

# This file was *autogenerated* from the file hash_gen.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_16 = Integer(16); _sage_const_6 = Integer(6)#!/usr/bin/python
import logging
from sage.rings.finite_rings.finite_field_constructor import GF
from sage.all import matrix
from sage.matrix.matrix_integer_dense import Matrix_integer_dense as Matrix
from sage.matrix.matrix_gf2e_dense import Matrix_gf2e_dense as MDSMatrix
from sage.rings.integer_ring import ZZ
from sage.matrix.special import random_matrix
from typing import Callable, Annotated, Iterator, Sequence, Generator
from sage.modules.vector_integer_dense import Vector_integer_dense as Vector
from random import shuffle, randint
from numpy import array
from copy import deepcopy
from re import compile
from datetime import datetime
from hashlib import sha3_256
from src.design2_byte import misc
# import misc

# F = GF(2**8, modulus=(1, 0, 0, 0, 1, 1, 0, 1, 1), name='x')
# print(F)
# x = polygen(GF(2), 'x')
F = GF(_sage_const_2 **_sage_const_8 , modulus=(_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_1 ), names=('x',)); (x,) = F._first_ngens(1)


# yapf does not understand type statments. Make sure to delete them when formatting.
Num = int
Row = Vector[int, misc.ROW_LENGTH]
Column = Vector[int, misc.COLUMN_LENGTH]
Lane = Vector[int, misc.LANE_LENGTH]
Panel = Vector[Vector[int, misc.COLUMN_LENGTH], misc.LANE_LENGTH]
Surface = Annotated[Vector[int, misc.ROW_LENGTH], misc.LANE_LENGTH]
Slice = Matrix[misc.ROW_LENGTH, misc.COLUMN_LENGTH]


class State(object):
    """
        The state is stored as a column.
        index order: z, y, x.
    """

    def __init__(self,
                 input: Annotated[list[Annotated[list[Annotated[list[int],
                                                                misc.ROW_LENGTH]],
                                                 misc.LANE_LENGTH]],
                                  misc.COLUMN_LENGTH]):
        """
            input: Slice[[Row], [Row], [Row], [Row], ...], Slice[[Row], [Row], [Row], [Row], ...], ...
        """
        t = len(input)
        if t != misc.LANE_LENGTH:
            raise TypeError(f'l is {t} long rather than {misc.LANE_LENGTH}!')
        t = len(input[_sage_const_0 ])
        if t != misc.COLUMN_LENGTH:
            raise TypeError(f'l[0] is {t} long rather than {misc.COLUMN_LENGTH}!')
        t = len(input[_sage_const_0 ][_sage_const_0 ])
        if t != misc.ROW_LENGTH:
            raise TypeError(
                f'l[0][0] is {t} long rather than {misc.ROW_LENGTH}!')
        self.__storage = [matrix(ll) for ll in input]

    def xor_with_message(self, message: misc.MessageBlock, use_fore: bool) -> None:
        zstart = _sage_const_0  if use_fore else misc.LANE_LENGTH // _sage_const_2 
        zend = misc.LANE_LENGTH // _sage_const_2  if use_fore else misc.LANE_LENGTH
        m_i = _sage_const_0 
        for z in range(zstart, zend):
            for y in range(_sage_const_0 , misc.COLUMN_LENGTH):
                for x in range(_sage_const_0 , misc.ROW_LENGTH):
                    self[z, y, x] = self[z, y, x] ** message[m_i]
                    m_i += _sage_const_1 

    def turncate_to_first_n_slice(self, n: int) -> tuple[int, Ellipsis]:
        """
            (slice0row0, slice0row1, slice0row2, slice0row3, slice1row0, ...)
        """
        return tuple(num for i in range(n) for num in self.__slice_to_tuple(i))

    def map(self, f: Callable[[Matrix], Matrix]) -> None:
        for z in range(misc.LANE_LENGTH):
            self[z] = f(self[z])

    def lane(self, y: int, x: int) -> Lane:
        return tuple(self[z, y, x] for z in range(misc.LANE_LENGTH))

    def set_lane(self, y: int, x: int, t: Sequence[int]) -> None:
        if len(t) != misc.LANE_LENGTH:
            raise ValueError(
                f'lane should be {misc.LANE_LENGTH} long but got {len(t)}!')
        for z in range(misc.LANE_LENGTH):
            self[z, y, x] = t[z]

    def __getitem__(self, pos):
        """
            z,y,x
        """
        if isinstance(pos, tuple):
            match len(pos):
                case _sage_const_3 :
                    z, y, x = pos
                    return self.__storage[z][y][x]
                case _sage_const_2 :
                    z, y = pos
                    return self.__storage[z][y]
                case _:
                    raise TypeError(f'Invalid subscription length {len(pos)}')
        else:
            z = pos
            return self.__storage[z]

    def __setitem__(self, pos, value):
        """
            z,y,x
        """
        if isinstance(pos, tuple):
            match len(pos):
                case _sage_const_3 :
                    z, y, x = pos
                    self.__storage[z][y, x] = value
                case _sage_const_2 :
                    z, y = pos
                    self.__storage[z][y] = value
                case _:
                    raise TypeError(f'Invalid subscription length {len(pos)}')
        else:
            z = pos
            self.__storage[z] = value

    def __slice_to_tuple(self, z: int) -> tuple[int, Ellipsis]:
        return tuple(i for r in self.__storage[z].rows() for i in r)

    def __iter__(self) -> Iterator:
        for matrix in self.__storage:
            yield matrix
        return None

    def __str__(self) -> str:
        lane_transform_constant = tuple(f'z = {z}:\n{self[z]}'
                                        for z in range(misc.LANE_LENGTH))
        return f'Matrix:\n{"|".join(lane_transform_constant)}\n\n '

    def __repr__(self) -> str:
        return str(self.turncate_to_first_n_slice(misc.LANE_LENGTH))

class SBox(object):

    BASE = _sage_const_16 

    def __init__(self, raw: tuple[tuple[int, Ellipsis], Ellipsis], prob_of_diff_path: int = _sage_const_6 ):
        self.__storage = raw
        self.__prob_of_diff_path = prob_of_diff_path

    @property
    def prob_of_diff_path(self) -> int:
        return self.__prob_of_diff_path

    def __getitem__(self, pos: int|tuple[int, Ellipsis]) -> int | tuple[int, Ellipsis]:
        if isinstance(pos, int):
            return self.__storage[pos]
        if len(pos) == _sage_const_2 :
            x,y = pos
            return self.__storage[x][y]
        raise TypeError('Too many dimensions for SBox!')

    def __str__(self) -> str:
        return str(self.__storage)


class HashFunction(object):

    @staticmethod
    def block_to_hash(b: misc.MessageBlock) -> misc.HashValue:
        """
            (00,01,02,ff) -> 000102ff
        """
        lane_transform_constant = [byte_.to_bytes() for byte_ in b]
        return hex(int.from_bytes(b''.join(lane_transform_constant)))

    @staticmethod
    def fill_and_block_message(message: misc.Message) -> tuple[misc.MessageBlock, Ellipsis]:
        mds = list(message)
        parts = list(mds[i:i + misc.BLOCK_SIZE]
                     for i in range(_sage_const_0 , len(mds), misc.BLOCK_SIZE))
        while len(parts[-_sage_const_1 ]) < misc.BLOCK_SIZE:
            parts[-_sage_const_1 ].append(_sage_const_0 )
        return tuple(
            map(lambda lane_transform_constant: tuple(lane_transform_constant),
                parts))

    @staticmethod
    def gen_state() -> State:
        length = misc.LANE_LENGTH * misc.ROW_LENGTH * misc.COLUMN_LENGTH
        st = list(range(misc.NUM_SIZE))
        shuffle(st)
        st = array( st[:length]).reshape( (misc.LANE_LENGTH, misc.ROW_LENGTH, misc.COLUMN_LENGTH)).tolist()
        return State(st)

    @staticmethod
    def __str_to_message(s: str) -> misc.Message:
        return tuple(bytes(s, 'utf-8'))

    @staticmethod
    def tuple_to_mds(t: tuple[tuple[int, Ellipsis], Ellipsis]) -> MDSMatrix:
        return matrix(tuple(tuple(map(lambda x: F.from_integer(int(x)), l)) for l in t))

    def __init__(self, round: int, round_constant: int, mds: tuple[tuple[int, Ellipsis], Ellipsis], shift_column_constants: Annotated[tuple[int, Ellipsis], misc.ROW_LENGTH], lane_transform_constants: tuple[tuple[int, Ellipsis], Ellipsis], sbox: tuple[tuple[int, Ellipsis], Ellipsis]):
        if len(shift_column_constants) != misc.ROW_LENGTH:
            raise ValueError(
                f'shift_column_constants shold be {misc.ROW_LENGTH} but got {len(shift_column_constants)}!'
            )
        self.__SHIFT_COLUMN_CONSTANTS = tuple(
            map(
                lambda x: (misc.COLUMN_LENGTH - x % misc.COLUMN_LENGTH) %
                misc.COLUMN_LENGTH, shift_column_constants))  # Check
        self.__ROUND = round
        self.__ROUND_CONSTANT = round_constant
        self.__MDS = self.tuple_to_mds(mds)
        self.__SBOX = SBox(sbox)
        self.__LINE_TRANSITION_CONSTANTS = matrix(lane_transform_constants)
        self.__INIT_STATE = self.gen_state()

    def __call__(self, input_: str) -> misc.HashValue:
        state = deepcopy(self.init_state)
        message = self.__str_to_message(input_)
        blocks = self.fill_and_block_message(message)
        for block in blocks:
            state.xor_with_message(block, True)
            for r in range(self.round):
                state = self.__permutation(state, r)
            state.xor_with_message(block, False)
        return self.block_to_hash(
            state.turncate_to_first_n_slice(misc.FINAL_USE_SLICE))

    def __str__(self) -> str:
        return f'''
--------------------杂凑函数--------------------
轮数: {self.round}
轮常数: {self.round_constant}

列移位常数: {self.shift_column_constants}

Lane变换常矩阵:
{self.line_transform_constants}

MDS矩阵:
{self.mds}

S盒:
{self.sbox}
------------------------------------------------
'''

    @property
    def round(self) -> int:
        return self.__ROUND

    @property
    def round_constant(self) -> int:
        return self.__ROUND_CONSTANT

    @property
    def mds(self) -> MDSMatrix:
        return self.__MDS

    @property
    def shift_column_constants(self) -> tuple[int, Ellipsis]:
        return self.__SHIFT_COLUMN_CONSTANTS

    @property
    def line_transform_constants(self) -> Matrix:
        return self.__LINE_TRANSITION_CONSTANTS

    @property
    def sbox(self) -> SBox:
        return self.__SBOX

    @property
    def field(self):
        return self.mds[_sage_const_0 , _sage_const_0 ].parent()

    @property
    def init_state(self) -> State:
        return self.__INIT_STATE

    def __permutation(self, s: State, r: int) -> State:
        s = self.__add_constant(s, r)
        s = self.__substitute_bytes(s, r)
        s = self.__shift_column(s, r)
        s = self.__mix_row(s, r)
        s = self.__lane_transform(s, r)
        return s

    def __add_constant(self, s: State, _: int) -> State:
        s.map(lambda mds: mds.apply_map(lambda x: x ** self.round_constant))
        return s

    def __substitute_bytes(self, s: State, _: int) -> State:
        s.map(lambda m: m.apply_map(lambda x: self.sbox[x // SBox.BASE, x % SBox.BASE]))
        return s

    def __mix_row_auxiliary(self, m: Matrix) -> Matrix:
        m = m.apply_map(lambda x: self.field.from_integer(x))
        m = self.mds * m
        return m.apply_map(lambda x: x.to_integer())

    def __mix_row(self, s: State, _: int) -> State:
        s.map(self.__mix_row_auxiliary)
        return s

    def __shift_column(self, s: State, _: int) -> State:
        for z in range(misc.LANE_LENGTH):
            slice = s[z]
            for x in range(misc.ROW_LENGTH):
                shift_pad = self.shift_column_constants[x]
                column = list(slice.column(x))
                column = column[shift_pad:] + column[:shift_pad]
                slice.set_column(x, column)
        return s

    def __lane_transform(self, s: State, _: int) -> State:
        for x in range(misc.ROW_LENGTH):
            for y in range(misc.COLUMN_LENGTH):
                shift_pad = self.line_transform_constants[y, x]
                lane = list(s.lane(y, x))
                lane = lane[shift_pad:] + lane[:shift_pad]
                s.set_lane(y, x, lane)
        return s

f = None

def generate_hash_function(round: int, round_constant: int, mds: tuple[tuple[int, Ellipsis], Ellipsis], shift_column_constants: Annotated[tuple[int, Ellipsis], misc.ROW_LENGTH], lane_transform_constants: tuple[tuple[int, Ellipsis], Ellipsis], sbox: tuple[tuple[int, Ellipsis], Ellipsis]) -> HashFunction:
    global f
    f = HashFunction(round, round_constant, mds, shift_column_constants, lane_transform_constants, sbox)

def hash_(s: str) -> str:
    if f:
        return f(s)
    else:
        return ''

